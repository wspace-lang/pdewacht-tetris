# Copyright 2008 Peter De Wachter
# Copyright 2020-2022 Andrew Archibald

# Heap partitions:
#   0-113
#   121-352 board
#   360     rand
#   361     read char
#   362     tmp
#   363     tmp

# Labels are assigned in order of usage

# A piece rotation is encoded as a 6-tuple containing the color ID (1-7),
# offsets for the four blocks, and the index of the next rotation for that
# piece.
#
# Piece rotations:
#
#   0
#   XX..
# O XX..  (1 red)
#   ....
#   ....
#
#   1     7
#   ....  .X..
# I XXXX  .X..  (2 green)
#   ....  .X..
#   ....  .#..
#
#   2     8     9     10
#   XXX.  .X..  X...  XX..
# J ..X.  .X..  XXX.  X...  (3 yellow)
#   ....  XX..  ....  X...
#   ....  ....  ....  ....
#
#   3     11    12    13
#   XXX.  XX..  ..X.  X...
# L X...  .X..  XXX.  X...  (4 blue)
#   ....  .X..  ....  XX..
#   ....  ....  ....  ....
#
#   4     14    15    16
#   XXX.  .X..  .X..  X...
# T .X..  XX..  XXX.  XX..  (5 magenta)
#   ....  .X..  ....  X...
#   ....  ....  ....  ....
#
#   5     17
#   XX..  .X..
# Z .XX.  XX..  (6 cyan)
#   ....  X...
#   ....  ....
#
#   6     18
#   .XX.  X...
# S XX..  XX..  (7 white)
#   ....  .X..
#   ....  ....
#
# Block offsets in 4x4 grid:
#   0  1  2  4
#   11 12 13 14
#   22 23 24 25
#   33 34 35 36

# Store piece data at addresses 0-113
    1  0  1  11 12 0  # O 0
    2  11 12 13 14 7  # I 1
    3  0  1  2  13 8  # J 2
    4  0  1  2  11 11 # L 3
    5  0  1  2  12 14 # T 4
    6  0  1  12 13 17 # Z 5
    7  1  2  11 12 18 # S 6
    2  1  12 23 34 1  # I 7
    3  1  12 22 23 9  # J 8
    3  0  11 12 13 10 # J 9
    3  0  1  11 22 2  # J 10
    4  0  1  12 23 12 # L 11
    4  2  11 12 13 13 # L 12
    4  0  11 22 23 3  # L 13
    5  1  11 12 23 15 # T 14
    5  1  11 12 13 16 # T 15
    5  0  11 12 22 4  # T 16
    6  1  11 12 22 5  # Z 17
    7  0  11 12 23 6  # S 18

    113 # Loop counter
init_heap_loop:
    swap ^1 swap
    store
    1-
    ^ jn .init_heap_done
    jmp init_heap_loop
.init_heap_done:
    drop

    # Initial seed
    360 123456 store

# Initial board:
#
#   121: -2  0  0  0  0  0  0  0  0  0  0
#   132: -2  0  0  0  0  0  0  0  0  0  0
#   143: -2  0  0  0  0  0  0  0  0  0  0
#   154: -2  0  0  0  0  0  0  0  0  0  0
#   165: -2  0  0  0  0  0  0  0  0  0  0
#   176: -2  0  0  0  0  0  0  0  0  0  0
#   187: -2  0  0  0  0  0  0  0  0  0  0
#   198: -2  0  0  0  0  0  0  0  0  0  0
#   209: -2  0  0  0  0  0  0  0  0  0  0
#   220: -2  0  0  0  0  0  0  0  0  0  0
#   231: -2  0  0  0  0  0  0  0  0  0  0
#   242: -2  0  0  0  0  0  0  0  0  0  0
#   253: -2  0  0  0  0  0  0  0  0  0  0
#   264: -2  0  0  0  0  0  0  0  0  0  0
#   275: -2  0  0  0  0  0  0  0  0  0  0
#   286: -2  0  0  0  0  0  0  0  0  0  0
#   297: -2  0  0  0  0  0  0  0  0  0  0
#   308: -2  0  0  0  0  0  0  0  0  0  0
#   319: -2  0  0  0  0  0  0  0  0  0  0
#   330: -2  0  0  0  0  0  0  0  0  0  0
#   341: -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2
#
# Cell values:
#   empty: 0
#   block: -1
#   wall:  -2

# Initialize board at addresses 121-352
    121 # Loop counter
init_board:
    # Edge
    ^ -2 store
    ^ 341 j= .init_board_bottom
.init_board_fill:
    1+
    # Center
    ^ 0 store
    ^ 11% jz init_board
    jmp .init_board_fill
.init_board_bottom:
    1+
    # Bottom
    ^ -2 store
    ^ 352 j< .init_board_bottom
    drop
    call draw_board_init

label_6:
    5 # Block position
    call rand
    call 4x_jn
    jn game_over

    call 4x_store_n1
read_key:
    call cursor_bottom_right
    361 readc
    call clear_piece
    2dup
    361 retrieve 'j'  j= .read_j
    361 retrieve 'k'  j= .read_k
    361 retrieve 'l'  j= .read_l
    361 retrieve 'i'  j= .read_i
    361 retrieve '\e' j= .read_esc
    jmp label_19
.read_j: # Move left
    swap 1- swap
    jmp label_20
.read_k: # Move down
    swap 11+ swap
    jmp label_21
.read_l: # Move right
    swap 1+ swap
    jmp label_20
.read_i: # Rotate
    5+ retrieve 6*
    jmp label_20
.read_esc:
    2drop
    jmp game_over

label_20:
    call 4x_jn
    jn label_19
    jmp label_22

label_21:
    call 4x_jn
    jn label_23
    jmp label_22

label_22:
    call 4x_store_n1
    362 swap store
    363 swap store
    2drop
    363 retrieve
    362 retrieve
    call 4x_store_n1
    jmp read_key
label_19:
    2drop
    call 4x_store_n1
    jmp read_key
label_23:
    2drop
    call 4x_store_n1
    2drop
    call label_24
    jmp label_6

game_over:
    call 4x_store_n1
    2drop
    call cursor_bottom_right
    call color_reverse
    " \n" prints  # Fill empty bottom-right corner
    "\e[G" prints # Move cursor to start of line
    call color_reset
    end

# Return a pseudorandom number in {6, 12, 18, 24, 32, 36}
# ( -- rand)
rand:
    # Update the rand state to (rand*279470273)%4294967291
    360 retrieve
    279470273* 4294967291%
    ^ 360 swap store
    # Return (rand%7)*6
    7% 6* ret

label_24:
    341
.outer_begin:
    11/ 11* 1-
    ^ 122 j< .ret
.inner_begin:
    ^ retrieve jz .outer_begin
    1-
    ^ 11% jz .break_inner
    jmp .inner_begin
.break_inner:
    ^ 11/ 10- call remove_filled_row
    ^ call .loop1
    11+
    jmp .outer_begin
.ret:
    drop ret

# (n -- )
.loop1:
    ^ ^ retrieve
    swap 11+ swap store
    ^ 122 j= .loop2
    1-
    jmp .loop1
# (122 -- )
.loop2:
    ^ 0 store
    1+
    ^ 11% jz .label_34
    jmp .loop2
.label_34:
    drop ret

# (x y -- x y n)
4x_jn:
    2dup
    swap 121+ swap
    1+ ^ retrieve ^2 + retrieve jn .neg
    1+ ^ retrieve ^2 + retrieve jn .neg
    1+ ^ retrieve ^2 + retrieve jn .neg
    1+ ^ retrieve ^2 + retrieve jn .neg
    2drop 0 ret
.neg:
    2drop -1 ret

4x_store_n1:
    call draw_piece
    swap 121+ swap
    1+ ^ retrieve ^2 + -1 store
    1+ ^ retrieve ^2 + -1 store
    1+ ^ retrieve ^2 + -1 store
    1+ ^ retrieve ^2 + -1 store
    4-
    swap 121- swap
    ret

# Clear piece in the heap and visually
clear_piece:
    call erase_piece
    swap 121+ swap
    1+ ^ retrieve ^2 + 0 store
    1+ ^ retrieve ^2 + 0 store
    1+ ^ retrieve ^2 + 0 store
    1+ ^ retrieve ^2 + 0 store
    4-
    swap 121 - swap
    ret

# Draw the piece with the color at the address c
# (x y c -- x y)
draw_piece:
    ^ retrieve call background
    jmp .draw_piece

# Erase the piece visually
# (x y -- x y)
erase_piece:
    0 call background # black

.draw_piece:
    1+ ^ retrieve ^2 + call label_40
    1+ ^ retrieve ^2 + call label_40
    1+ ^ retrieve ^2 + call label_40
    1+ ^ retrieve ^2 + call label_40
    4-
    ret

# (n -- )
label_40:
    ^
    # Move cursor to line (n/11+1), col ((n%11)*2+1)
    "\e[" prints
    11/ 1+ printi
    ';' printc
    11% 2* 1+ printi
    'H' printc
    "\e[2X" prints # Erase next 2 characters without moving cursor
    "  " prints
    ret

# Remove a filled row and shift the board down
# (line -- )
remove_filled_row:
    call color_reset
    "\e[" prints printi 'H' printc # Move cursor to line
    "\e[1M" prints # Delete current line and shift remaining lines up
    jmp draw_board_row # Add empty row at top

# Draw an empty board
# ( -- )
draw_board_init:
    "\e[2J" prints # Clear entire screen
    # Draw floor except for bottom-right corner
    "\e[H" prints # Move cursor to upper-left corner
    call color_reverse
    23 call print_spaces
    # Draw 20 rows of walls
    -20
.draw_board_init_loop:
    call draw_board_row
    1+
    ^ jn .draw_board_init_loop
    drop ret

# Insert a line at the top of the board and draw walls
# ( -- )
draw_board_row:
    call color_reset
    "\e[H" prints # Move cursor to upper-left corner
    "\e[L" prints # Insert line at cursor position
    call color_reverse
    "  " prints       # Draw left wall
    "\e[23G  " prints # Draw right wall at column 23
    ret

# Move cursor to the bottom-right corner, where user input is read
# ( -- )
cursor_bottom_right:
    "\e[21;24H" prints # Move cursor to line 21, col 24
    jmp color_reset

# Reverse video on
# ( -- )
color_reverse:
    "\e[0;7m" prints
    ret

# Reset attributes and set background color, given 0-7
#   40 black
#   41 red
#   42 green
#   43 yellow
#   44 blue
#   45 magenta
#   46 cyan
#   47 white
# (color -- )
background:
    "\e[0;4" prints
    printi
    'm' printc
    ret

# Reset all attributes
# ( -- )
color_reset:
    "\e[0m" prints
    ret

# Print n spaces
# (n -- )
print_spaces:
    ^ jz .print_spaces_ret
    ' ' printc
    1-
    jmp print_spaces
.print_spaces_ret:
    drop ret

# Print "Crash!" and dump the stack
# ( -- )
dump_stack:
    "\nCrash!\n" prints
.dump_stack_loop:
    printi
    '\n' printc
    jmp .dump_stack_loop

# Dump heap values above 121
# ( -- )
dump_heap:
    121
.dump_heap_loop:
    ^ retrieve printi
    ';' printc
    1+
    jmp .dump_heap_loop

# Prints the board state below the board.
debug_dump_board:
    "\e[22H" prints # Move cursor to line 22
    call color_reset
    "\e[0J" prints # Clear from cursor to screen end
    121
.debug_dump_board_loop:
    ^ 11% jz .debug_dump_board_line_number
.debug_dump_board_cell:
    ' ' printc
    ^ retrieve printi
    1+
    ^ 353 j< .debug_dump_board_loop
    '\n' printc
    drop
    call debug_dump_stack
    ret
.debug_dump_board_line_number:
    '\n' printc
    ^ printi
    ':' printc
    jmp .debug_dump_board_cell

# Prints the values on the stack nondestructively.
# Requires that -999999999 be at the bottom of the stack.
# Can only print up to 20 stack elements.
debug_dump_stack:
    "\e[46H" prints # Move cursor to line 36
    call color_reset
    "\e[0J" prints # Clear from cursor to screen end
    ^   ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^1  ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^2  ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^3  ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^4  ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^5  ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^6  ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^7  ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^8  ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^9  ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^10 ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^11 ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^12 ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^13 ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^14 ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^15 ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^16 ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^17 ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^18 ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    ^19 ^ -999999999 j= .debug_dump_stack_ret printi '\n' printc
    "Too many elements to print\n" prints
.debug_dump_stack_ret:
    drop ret
